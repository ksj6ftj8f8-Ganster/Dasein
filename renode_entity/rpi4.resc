# rpi4.resc → descripción de la placa virtual y el PUENTE de simulación
using "platforms/cpus/rpi4.repl"

// CPU Cortex-A72 (4 núcleos)
cpu0: CPU.CortexA72 @ sysbus 0x0
    cores: 4

// RAM 4 GB LPDDR4
ram: Memory.MappedMemory @ sysbus 0x0 size: 0x100000000

// INA219 virtual (I2C-GPIO2-3)
ina219: Sensors.INA219 @ sysbus 0x80400000 -> i2c1 @ 0

// GPS 1 PPS virtual (GPIO18)
gps_pps: GPIO.GPButton @ gpio 0x12 -> pps_irq @ 0

// SSD USB virtual (raw)
ssd: Storage.MassStorage @ sysbus 0x90000000 size: 0x100000000 -> usb @ 0

// Determinismo: seed fijo
setSeed 0x5F3A9C

// <<!-- CORRECCIÓN CRÍTICA -->>
// PUENTE: Script Python que conecta la actividad de la CPU con el sensor virtual
python:
"""
from Antmicro.Renode.Core import *
from Antmicro.Renode.Peripherals.CPU import *
from Antmicro.Renode.Logging import *

# Modelo de fuga simplificado: Energía = (Instrucciones * C1) + (Cache Misses * C2)
def power_leakage_model(cpu, ina219_sensor):
    try:
        # Obtener contadores de rendimiento del CPU
        instructions_retired = long(cpu.GetPerformanceCounterValue("InstructionsRetired"))
        l1d_cache_misses = long(cpu.GetPerformanceCounterValue("L1DCacheMiss"))
        
        # Constantes de energía (calibradas empíricamente contra el hardware real)
        C1 = 0.0001  # Energía por instrucción
        C2 = 0.01    # Energía por fallo de caché
        
        # Calcular la energía virtual
        virtual_energy = (instructions_retired * C1) + (l1d_cache_misses * C2)
        
        # Convertir energía a un valor de Shunt Voltage para el INA219
        # (El factor de conversión también se calibra)
        shunt_voltage_value = int(virtual_energy * 500)
        
        # Limitar el valor al rango válido del INA219
        shunt_voltage_value = max(-32768, min(32767, shunt_voltage_value))
        
        # Actualizar el registro del sensor virtual
        ina219_sensor.ShuntVoltage = shunt_voltage_value
        
        # Log para debugging
        #Logger.LogAsSource(LogLevel.Noisy, f"Power model: {virtual_energy:.6f} J, Shunt: {shunt_voltage_value} μV")
        
    except Exception as e:
        Logger.LogAsSource(LogLevel.Warning, f"Error in power model: {str(e)}")

# Enganchar el modelo para que se ejecute cada 1,000,000 de ciclos de reloj virtuales
cpu0.AddHook(lambda cpu: power_leakage_model(cpu, ina219), 1000000)
"""

// Configuración de red para comunicación
emulation CreateSwitch "switch"
emulation CreateTap "tap0" "tap"
cpu0 SetNetworkInterface "tap0"

// Configuración de watchdog para estabilidad
watchdog: Timers.Watchdog @ sysbus 0x7E100000
    -> cpu0 @ 0

// Configuración de UART para logging
uart0: UART.STM32_UART @ sysbus 0x7E201000
    -> cpu0 @ 1

// Timer para mediciones periódicas
timer0: Timers.STM32_Timer @ sysbus 0x7E003000
    -> cpu0 @ 2

// Configuración de GPIO para señales de control
gpio0: GPIOPort.STM32_GPIOPort @ sysbus 0x7E200000
    -> cpu0 @ 3

// Inicializar sistema
machine LoadPlatformDescriptionFromString ""

// Configurar el sistema operativo
machine LoadBinary @"linux_image"

// Configurar parámetros de arranque
machine SetCommandLine "console=ttyAMA0,115200 root=/dev/mmcblk0p2 rw"

// Configurar el entorno de simulación
showAnalyzer sysbus.uart0

// Iniciar la simulación
start